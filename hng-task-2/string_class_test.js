// Generated By AI

import StringStore from "./string_class.js";

let passed = 0;
let failed = 0;

function assert(condition, message) {
  if (condition) {
    console.log(`✅ PASS: ${message}`);
    passed++;
  } else {
    console.log(`❌ FAIL: ${message}`);
    failed++;
  }
}

function assertEqual(actual, expected, message) {
  if (JSON.stringify(actual) === JSON.stringify(expected)) {
    console.log(`✅ PASS: ${message}`);
    passed++;
  } else {
    console.log(`❌ FAIL: ${message}`);
    console.error(`  Expected: ${JSON.stringify(expected)}`);
    console.error(`  Got: ${JSON.stringify(actual)}`);
    failed++;
  }
}

function runTests() {
  console.log('Running StringStore Tests...\n');

  let store;

  // Test constructor
  console.log('Testing constructor:');
  store = new StringStore([]);
  assertEqual(store.store_array, [], 'Constructor initializes with empty array');
  store = new StringStore([{ value: 'test', properties: { length: 4 } }]);
  assertEqual(store.store_array.length, 1, 'Constructor initializes with provided array');

  // Test getStringProperties
  console.log('\nTesting getStringProperties:');
  store = new StringStore([]);
  const props = store.getStringProperties('racecar');
  assert(props && props.value === 'racecar' && props.properties.length === 7 && props.properties.is_palindrome === true &&
         props.properties.word_count === 1 && props.properties.unique_characters === 4 &&
         typeof props.properties.sha256_hash === 'string',
         'Returns correct properties for valid string');
  assert(store.getStringProperties('') === null, 'Returns null for empty string');
  assert(store.getStringProperties(undefined) === null, 'Returns null for undefined input');

  // Test hashString
  console.log('\nTesting hashString:');
  const hash = store.hashString('test');
  assert(hash && /^[0-9a-f]{64}$/.test(hash), 'Returns valid SHA-256 hash');
  assert(store.hashString('') === null, 'Returns null for empty string');

  // Test getCharacterFrequencyMap
  console.log('\nTesting getCharacterFrequencyMap:');
  assertEqual(store.getCharacterFrequencyMap('hello'), { h: 1, e: 1, l: 2, o: 1 }, 'Returns correct frequency map');
  assert(store.getCharacterFrequencyMap('') === null, 'Returns null for empty string');

  // Test addString (NOW PASSING STRINGS DIRECTLY)
  console.log('\nTesting addString:');
  store = new StringStore([]);
  store.addString('hello');
  assert(store.store_array.length === 1 && store.store_array[0].value === 'hello', 'Adds valid string');
  assert(store.addString('hello') === '409', 'Returns 409 for duplicate string');
  assert(store.addString('') === undefined, 'Handles empty string (no add)');
  store.addString('non-string-test'); // Reset for next tests

  // Test getString
  console.log('\nTesting getString:');
  store = new StringStore([]);
  store.addString('test');
  assert(store.getString('test')?.value === 'test', 'Retrieves existing string');
  assert(store.getString('nonexistent') === null, 'Returns null for non-existent string');
  assert(store.getString('') === null, 'Returns null for empty string');

  // Test getFilteredStrings (FIXED VERSION REQUIRED - see below)
  console.log('\nTesting getFilteredStrings:');
  store = new StringStore([]);
  store.addString('racecar');
  store.addString('hello world');
  store.addString('z');
  let result = store.getFilteredStrings({ is_palindrome: true });
  assert(result && result.count === 2 && result.data[0].value === 'racecar', 'Filters palindromes');
  result = store.getFilteredStrings({ min_length: 5, max_length: 10 });
  assert(result && result.count === 1 && result.data[0].value === 'racecar', 'Filters by min_length and max_length');
  result = store.getFilteredStrings({ word_count: 2 });
  assert(result && result.count === 1 && result.data[0].value === 'hello world', 'Filters by word_count');
  result = store.getFilteredStrings({ contains_character: 'z' });
  assert(result && result.count === 1 && result.data[0].value === 'z', 'Filters by contains_character');
  store.addString('deked');
  result = store.getFilteredStrings({ is_palindrome: true, min_length: 5 });
  assert(result && result.count === 2, 'Handles combined filters');
  assert(store.getFilteredStrings(null) === null, 'Returns null for empty filter');

  // Test getByNaturalLanguageFilter
  console.log('\nTesting getByNaturalLanguageFilter:');
  store = new StringStore([]);
  store.addString('racecar');
  store.addString('hello world');
  store.addString('z');
  store.addString('deked');
  result = store.getByNaturalLanguageFilter('all single word palindromic strings');
  assert(result && result.count === 3, 'Filters single word palindromes');
  result = store.getByNaturalLanguageFilter('strings longer than 10 characters');
  assert(result && result.count === 1 && result.data[0].value === 'hello world', 'Filters strings longer than 10 characters');
  result = store.getByNaturalLanguageFilter('palindromic strings that contain the first vowel');
  assert(result && result.count === 1 && result.data[0].value === 'racecar', 'Filters palindromes with first vowel (a)');
  result = store.getByNaturalLanguageFilter('strings containing the letter z');
  assert(result && result.count === 1 && result.data[0].value === 'z', 'Filters strings containing z');
  assert(store.getByNaturalLanguageFilter('invalid input') === '422', 'Returns 422 for invalid natural language input');
  assert(store.getByNaturalLanguageFilter('') === null, 'Returns null for empty input');

  // Test deleteString
  console.log('\nTesting deleteString:');
  store = new StringStore([]);
  store.addString('test');
  store.deleteString('test');
  assert(store.store_array.length === 0, 'Deletes existing string');
  assert(store.deleteString('nonexistent') === '404', 'Returns 404 for non-existent string');
  assert(store.deleteString('') === null, 'Returns null for empty string');

  // Test edge cases
  console.log('\nTesting edge cases:');
  store = new StringStore([]);
  const longString = 'a'.repeat(1000);
  store.addString(longString);
  assert(store.getString(longString)?.properties.length === 1000, 'Handles very long string');
  store.addString('@#$%');
  result = store.getFilteredStrings({ contains_character: '#' });
  assert(result && result.count === 1 && result.data[0].value === '@#$%', 'Handles special characters');

  // Summary
  console.log(`\nTest Summary: ${passed} passed, ${failed} failed`);
}

runTests();